# -*- coding: utf-8 -*-
"""Perceptron.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fRmkr77gaJx1ErXc_TM-oHO8hRc70Jp_

# Perceptron 

Treinamento de um perceptron para classificação de imagens preto e branco, representadas por uma matriz de pixels 3x3, em "clara" ou "escura".
 - Pixels brancos = 1 e pixels pretos = -1

Fonte: [Link](https://edisciplinas.usp.br/pluginfile.php/4457290/mod_resource/content/2/SIN5007-Tema08-RedesNeurais.pdf)
"""

# Dados iniciais
import numpy as np

# Base de dados
# Classe 1 (predominantemente branca)
A = np.array( [1, -1, 1, -1, 1, 1, -1, -1, 1] )

# Classe -1 (predominantemente preta)
B = np.array( [-1, -1, -1, 1, -1, 1, 1, 1, -1] )

# Classe 1 (predominantemente branca)
C = np.array( [1, -1, 1, 1, -1, 1, -1, 1, 1] )

# Pesos iniciais (pesos igual para que as entradas tenha mesma relevância)
Pesos = np.array( [0.11, 0.11, 0.11, 0.11, 0.11, 0.11, 0.11, 0.11, 0.11] )

# Taxa de aprendizagem
eta = 0.1

# Viés
bias = -0.5

# Função para a soma ponderada
# u = x0*w0 + x1*w1 + x2*w2 + 1*θ
# m = x0*w0 + x1*w1 + x2*w2
# u = m + 1*θ

def somaPonderada(X, W):
  bias = -0.5
  m = np.multiply(X, W)
  u = np.sum(m) + 1*bias
  return u

# Função de ativação
# Função Degrau

def funcaoAtivacao(u):
  if u >= 0:
    return 1
  else:
    return -1

# Função de saída

def saida(X, W):
  u = somaPonderada(X, W)
  return funcaoAtivacao(u)

# Função para ajustes dos pesos
# Parte central do processo de aprendizagem
# Novo wi  →  wi = wi +  η xi (d - y)

def ajustaPesos(eta, W, X, bias, d, y):
  e = d - y
  novoW = W + eta*X*e
  novoB = bias + eta*(-1)*e
  return novoW, novoB

"""# Treinamento 
* Realizado manualmente para ilustrar o processo 
* Aprsenta uma entrada e calcula a saída de maneira iterativa

## Iteração 1
"""

# Entrada predominantemente branca saída +1
d = 1
y = saida(A, Pesos)
print(y)
# Ajuste dos pesos
Pesos, bias = ajustaPesos(eta, Pesos, A, bias, d, y)
print(Pesos)
print(bias)

print("-----")

# Entrada predominantemente preta saída -1
d = -1
y = saida(B, Pesos)
print(y)
#Ajuste dos pesos
Pesos, bias = ajustaPesos(eta, Pesos, B, bias, d, y)
print(Pesos)
print(bias)

print("-----")

# Entrada predominantemente branca saída +1
d = 1
y = saida(C, Pesos)
print(y)
#Ajuste dos pesos
Pesos, bias = ajustaPesos(eta, Pesos, C, bias, d, y)
print(Pesos)
print(bias)

"""## Iteração 2"""

# Entrada predominantemente branca saída +1
d = 1
y = saida(A, Pesos)
print(y)
# Ajuste dos pesos
Pesos, bias = ajustaPesos(eta, Pesos, A, bias, d, y)
print(Pesos)
print(bias)

print("-----")

# Entrada predominantemente preta saída -1
d = -1
y = saida(B, Pesos)
print(y)
#Ajuste dos pesos
Pesos, bias = ajustaPesos(eta, Pesos, B, bias, d, y)
print(Pesos)
print(bias)

print("-----")

# Entrada predominantemente branca saída +1
d = 1
y = saida(C, Pesos)
print(y)
#Ajuste dos pesos
Pesos, bias = ajustaPesos(eta, Pesos, C, bias, d, y)
print(Pesos)
print(bias)

"""# Teste
* A que classe pertencem os padrões 111, 000, 100 e 011?
"""

# Padrão "claro"
T = np.array( [1, 1, 1, -1, 1, 1, 1, -1, 1] )
print("Saida para ", T, " é ", saida(T, Pesos))

# Padrão "escuro"
T = np.array( [-1, -1, 1, -1, -1, -1, -1, -1, 1] )
print("Saida para ", T, " é ", saida(T, Pesos))

# Padrão "claro"
T = np.array( [1, 1, 1, 1, 1, 1, -1, 1, 1] )
print("Saida para ", T, " é ", saida(T, Pesos))

# Padrão "escuro"
T = np.array( [1, -1, -1, -1, 1, -1, -1, -1, -1] )
print("Saida para ", T, " é ", saida(T, Pesos))

# Padrão "claro"
T = np.array( [-1, -1, 1, -1, 1, 1, 1, -1, 1] )
print("Saida para ", T, " é ", saida(T, Pesos))

# Padrão "claro"
T = np.array( [-1, -1, -1, 1, 1, 1, 1, -1, 1] )
print("Saida para ", T, " é ", saida(T, Pesos))